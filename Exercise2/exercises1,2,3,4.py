# -*- coding: utf-8 -*-
"""Cópia de Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kiMmej7QarJ9zeQDNk7mDPjkCHCPv_Xu
"""

"""# 1) Codigo para convolução"""

def conv(img, kernel):
  img = img.astype(float)

  imgVect=[]
  kernel_x = len(kernel)//2
  kernel_y = len(kernel[0])//2
  for row in range(len(kernel)):
    for col in range(len(kernel[row])):                       #cria um vetor com as posições relativas ao pixel atual
      imgVect.append([col - kernel_x,row - kernel_y])

  # for i in range(len(kernel)):
  #   for j in range(len(kernel[i])):                           #função só p imprimir os valores do vetor de cima em formato de matriz
  #     print(imgVect[i*len(kernel[0])+j],end="")
  #   print()

  cuttedImg_kernelSize = []                                   #sera usado para armazenar m pixels adjacentes(conforme valor do kernel) para cada pixel n na imagem
                                                              #basicamente terá n vetores do tamanho do kernel, com cada elemento desse vetor sendo os pixels adjacentes
  for i in range(len(img)):
    for j in range(len(img[i])):                              #percorre a imagem inteira

      aroundPixels = []                                       #aqui criamos uma lista temporaria para que seja adicionado cada pixel adjacente para que depois fique mais facil adicionar o vetor inteiro diretamente em "cuttedImg_kernelSize"

      for element in imgVect:
        if i+element[1] >= 0 and i+element[1] < len(img) and j+element[0] >= 0 and j+element[0] < len(img[i]):  # element[0] = coluna do vetor de posições relativas
          aroundPixels.append(img[i+element[1]][j+element[0]])                                               # element[1] = linha do vetor de posições relativas
        else:                                                                                                   #basicamente,para cada elemento adjacente ao pixel img[i][j]
          aroundPixels.append(0.0)                                                                              #se estiver fora do range da imagem recebe valor 0 no resultado que fica em "cuttedImg_kernelSize"
                                                                                                                #se estiver dentro do range recebe seu proprio valor

      cuttedImg_kernelSize.append(aroundPixels)


  kernel_flat = kernel.flatten().tolist()   #transforma o kernel em um vetor com cada elemento da matriz "kernel" (para facilitar a multiplicação)

  # Aplica a convolução: multiplicando os valores de cada elemento do kenel por cada elemento de cada pixel da imagem(em "cuttedImg_kernelSize")
  result = np.zeros((img.shape[0], img.shape[1])) #apenas cria uma matriz de 0's do tamanho de imagem para atribuir os valores para cada pixel com kernel aplicado para que possa ser retornado como resultado
  idx = 0
  for i in range(img.shape[0]):
      for j in range(img.shape[1]):
          # Multiplica elemento a elemento do kernel pelo atual vetor de "cuttedImg_kernelSize" e soma todos. Resultando no pixel com o kernel aplicado
          conv_value = sum([a*b for a,b in zip(cuttedImg_kernelSize[idx], kernel_flat)])
          result[i,j] = conv_value
          idx += 1

  result = np.clip(result, 0, 255)   # corta valores fora do range
  result = result.astype(np.uint8)   # converte de voltapra uint
  return result

"""---

# 2.1) Codigo de Mediana:
"""

def median(img, kernel_x, kernel_y):
  img = img.astype(float)

  imgVect=[]
  indexX = kernel_x//2
  indexY = kernel_y//2
  for row in range(kernel_x):        # cria um vetor com as posições relativas ao pixel atual com base no tamanho x e y do kernel passado
    for col in range(kernel_y):
      imgVect.append([col - indexX,row - indexY])

  # for i in range(kernel_x):
  #   for j in range(kernel_y):
  #     print(imgVect[i*kernel_x+j],end="")
  #   print()

#                     vvvvvv aqui o codigo é identico ao da convolução
  medianPixel = []
  for i in range(len(img)):
    for j in range(len(img[i])):

      aroundPixels = []

      for element in imgVect:
        if i+element[1] >= 0 and i+element[1] < len(img) and j+element[0] >= 0 and j+element[0] < len(img[i]):
          aroundPixels.append(img[i+element[1]][j+element[0]])
        else:
          aroundPixels.append(0.0)

#                     ^^^^^^ aqui o codigo é identico ao da convolução

      aroundPixels.sort()                                     # pega o vetor de pixels adjacentes á img[i][j] e ordena
      aroundPixels = aroundPixels[len(aroundPixels)//2]       # pega o valor mediano desse vetor e reutiliza a mesma variavel arounPixels(que antes era vetor, agora é apenas 1 valor)
      medianPixel.append(aroundPixels)                        # guarda o valor em mediano das adjacencias de cada pixel em medianPixel

  result = np.zeros((img.shape[0], img.shape[1]))

  for i in range(img.shape[0]):
      for j in range(img.shape[1]):                           # atribui o valor mediano de cada pixel no index correspondente do resultado.
          result[i,j] = medianPixel[i*img.shape[1]+j]         #   como median pixel é um vetor unidimensional do tamanho dos pixels da imagem, basta usar a formula "i*img.shape[1]+j" para obter o index de "[i][j]" de uma matriz

  result = result.astype(np.uint8)
  return result

"""# 2.2) Codigo de Max:"""

def max(img, kernel_x, kernel_y):
  img = img.astype(float)

  imgVect=[]
  indexX = kernel_x//2
  indexY = kernel_y//2
  for row in range(kernel_x):
    for col in range(kernel_y):
      imgVect.append([col - indexX,row - indexY])

  # for i in range(kernel_x):
  #   for j in range(kernel_y):
  #     print(imgVect[i*kernel_x+j],end="")
  #   print()

  maxPixel = []
  for i in range(len(img)):
    for j in range(len(img[i])):

      aroundPixels = []

      for element in imgVect:
        if i+element[1] >= 0 and i+element[1] < len(img) and j+element[0] >= 0 and j+element[0] < len(img[i]):
          aroundPixels.append(img[i+element[1]][j+element[0]])
        else:
          aroundPixels.append(0.0)

                                                          #mesmo codigo da mediana, unica diferença é que nessa parte em vez de pegar o valor mediano, pega o valor maximo
      aroundPixels = np.array(aroundPixels).max()         # transforma em np.array para utilizar a função max() e achar o maior pixel adjacente
                                                          #     (mas tambem pode ser feito da maneira como está comentado abaixo)

      # aroundPixels.sort()
      # aroundPixels = aroundPixels[len(aroundPixels)-1]    #pega o ultimo pixel do vetor ordenado

      maxPixel.append(aroundPixels)

  result = np.zeros((img.shape[0], img.shape[1]))

  for i in range(img.shape[0]):
      for j in range(img.shape[1]):
          result[i,j] = maxPixel[i*img.shape[1]+j]

  result = result.astype(np.uint8)
  return result

"""# 2.3) Codigo de Min:"""

def min(img, kernel_x, kernel_y):
  img = img.astype(float)

  imgVect=[]
  indexX = kernel_x//2
  indexY = kernel_y//2
  for row in range(kernel_x):
    for col in range(kernel_y):
      imgVect.append([col - indexX,row - indexY])

  # for i in range(kernel_x):
  #   for j in range(kernel_y):
  #     print(imgVect[i*kernel_x+j],end="")
  #   print()

  minPixel = []
  for i in range(len(img)):
    for j in range(len(img[i])):

      aroundPixels = []

      for element in imgVect:
        if i+element[1] >= 0 and i+element[1] < len(img) and j+element[0] >= 0 and j+element[0] < len(img[i]):
          aroundPixels.append(img[i+element[1]][j+element[0]])
        else:
          aroundPixels.append(0.0)

                                                          #mesmo codigo da mediana, unica diferença é que nessa parte em vez de pegar o valor mediano, pega o valor minimo
      aroundPixels = np.array(aroundPixels).min()         # transforma em np.array para utilizar a função min() e achar o menor pixel adjacente
                                                          #     (mas tambem pode ser feito da maneira como está comentado abaixo)

      # aroundPixels.sort()
      # aroundPixels = aroundPixels[0]                    #pega o ultimo pixel do vetor ordenado

      minPixel.append(aroundPixels)

  result = np.zeros((img.shape[0], img.shape[1]))

  for i in range(img.shape[0]):
      for j in range(img.shape[1]):
          result[i,j] = minPixel[i*img.shape[1]+j]

  result = result.astype(np.uint8)
  return result

"""# 2.3) Codigo de Ponto Médio:"""

def pontoMedio(img, kernel_x, kernel_y):
  img = img.astype(float)

  imgVect=[]
  indexX = kernel_x//2
  indexY = kernel_y//2
  for row in range(kernel_x):
    for col in range(kernel_y):
      imgVect.append([col - indexX,row - indexY])

  # for i in range(kernel_x):
  #   for j in range(kernel_y):
  #     print(imgVect[i*kernel_x+j],end="")
  #   print()

  pontoMedioPixel = []
  for i in range(len(img)):
    for j in range(len(img[i])):

      aroundPixels = []

      for element in imgVect:
        if i+element[1] >= 0 and i+element[1] < len(img) and j+element[0] >= 0 and j+element[0] < len(img[i]):
          aroundPixels.append(img[i+element[1]][j+element[0]])
        else:
          aroundPixels.append(0.0)


      min = np.array(aroundPixels).min()         # calcula o valor minimo dos adjacentes
      max = np.array(aroundPixels).max()         # calcula o valor maximo dos adjacentes

      aroundPixels = (min+max)//2                #soma e divide por 2 (numeros inteiros como resultado)

      pontoMedioPixel.append(aroundPixels)

  result = np.zeros((img.shape[0], img.shape[1]))

  for i in range(img.shape[0]):
      for j in range(img.shape[1]):
          result[i,j] = pontoMedioPixel[i*img.shape[1]+j]

  result = result.astype(np.uint8)
  return result

def printImg(title,*imgs):
    for img in imgs:
        print(title)
        cv2.imshow(title, img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()

import cv2
import numpy as np
import matplotlib.pyplot as plt

img1 = cv2.imread(r"C:\Users\enzoc\OneDrive\Documentos\ComputionalVision\Exercise2\item1.png", cv2.IMREAD_GRAYSCALE)
img2 = cv2.imread(r"C:\Users\enzoc\OneDrive\Documentos\ComputionalVision\Exercise2\item2.jpg", cv2.IMREAD_GRAYSCALE)
img3 = cv2.imread(r"C:\Users\enzoc\OneDrive\Documentos\ComputionalVision\Exercise2\item3.1.jpg", cv2.IMREAD_GRAYSCALE)
img4 = cv2.imread(r"C:\Users\enzoc\OneDrive\Documentos\ComputionalVision\Exercise2\item3.2.jpg", cv2.IMREAD_GRAYSCALE)
img5 = cv2.imread(r"C:\Users\enzoc\OneDrive\Documentos\ComputionalVision\Exercise2\item3.3.jpg", cv2.IMREAD_GRAYSCALE)

k = np.array([[-1,-2,-1],
              [0,0,0],
              [1,2,1]])

k3x3 = np.ones((3,3), dtype=float) / 9
k7x7 = np.ones((7,7), dtype=float) / 49
k9x9 = np.ones((9,9), dtype=float) / 81
#função:  gaussiana (neutraliza ruidos para um estagio mais suave) + mediana (remove o "grosso" do ruido)

def gauss(x, y, sigma):
    return (1 / (2 * np.pi * sigma**2)) * np.exp(-(x**2 + y**2) / (2 * sigma**2))

def kernel_gauss(size, sigma):
    kernel = np.ones((size, size))
    for i in range(size):
        for j in range(size):
            kernel[i, j] = gauss(i - size // 2, j - size // 2, sigma)
    return kernel / np.sum(kernel)

import time
import sys

def progress_bar(current, total, bar_length=40):
    percent = current / total
    filled = int(bar_length * percent)
    bar = "█" * filled + "-" * (bar_length - filled)
    sys.stdout.write(f"\rCarregando: |{bar}| {percent:.0%}")
    sys.stdout.flush()
    if current == total:
        print()  # pula linha ao terminar

"""Carrega todas as imagens antes de executar o programa (para melhor fluidez, por que carrega uma só vez e executa tudo)"""

total = 14
count = 0

progress_bar(count, total)
buffer1 = conv(img1, k); count += 1; progress_bar(count, total)
buffer2 = median(img1, 5, 5); count += 1; progress_bar(count, total)
buffer3 = max(img1, 5, 5); count += 1; progress_bar(count, total)
buffer4 = min(img1, 5, 5); count += 1; progress_bar(count, total)
buffer5 = pontoMedio(img1, 5, 5); count += 1; progress_bar(count, total)
buffer6 = conv(img2, k3x3); count += 1; progress_bar(count, total)
buffer7 = conv(img2, k7x7); count += 1; progress_bar(count, total)
buffer8 = conv(img2, k9x9); count += 1; progress_bar(count, total)
buffer9 = median(img2, 3, 3); count += 1; progress_bar(count, total)
buffer10 = median(img2, 7, 7); count += 1; progress_bar(count, total)
buffer11 = median(img2, 9, 9); count += 1; progress_bar(count, total)
buffer12 = median(img3, 3, 3); count += 1; progress_bar(count, total)
buffer13 = median(img4, 3, 3); count += 1; progress_bar(count, total)
buffer14 = conv(median(img5, 6, 6), kernel_gauss(5, 1)); count += 1; progress_bar(count, total)


printImg("Imagem 1:",img1)
"""1.R) Executa o codigo de convolução:"""

printImg("Imagem 1 Com Convolucao:",buffer1)



"""2.1.R) Executa o codigo de mediana:"""

printImg("Imagem 1 Com Mediana:",buffer2)



"""2.2.R) Executa o codigo de maximo:"""

printImg("Imagem 1 Com Max:",buffer3)



"""2.3.R) Executa o codigo de minimo:"""

printImg("Imagem 1 Com Min:",)



"""2.4.R) Executa o codigo de ponto médio:"""

printImg("Imagem 1 Com Ponto Medio:",buffer5)

"""---

# 3) Aplicar filtro de Media e Mediana
"""

printImg("Imagem 2:",img2)

"""3.a) Filtro de média"""

tmp=[["3x3",buffer6],["7x7",buffer7],["9x9",buffer8]]
for size in tmp:
    printImg(f"Imagem 2 Com filtro de Media {size[0]}:",size[1])


tmp=[["3x3",buffer9],["7x7",buffer10],["9x9",buffer11]]
for size in tmp:
    printImg(f"Imagem 2 Com filtro de Mediana {size[0]}:",size[1])


tmp = [[3,img3],[4,img4],[5,img5]]
for size in tmp:
    printImg(f"Imagem {size[0]} :",size[1])

#mediana é bem apta para remover ruidos sal e pimenta. Por isso essa foi a convolução escolhida:


printImg("Imagem 3 :",img3)
printImg("Imagem 3 Com filtro de Mediana. (normalizando os ruidos):",buffer12)
printImg("Imagem 4 :",img4)
printImg("Imagem 3 Com filtro de Mediana. (normalizando os ruidos):",buffer13)


printImg("Imagem 5 :",img5)
printImg("Imagem 5 Com filtro de Mediana e Gauss. (normalizando os ruidos):",buffer14)